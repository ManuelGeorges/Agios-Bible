'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import styles from './Bible.module.css';
import { useLanguage } from '../../context/LanguageContext';
import { useSearchParams } from 'next/navigation';

// ÿØÿßŸÑÿ© ŸÑÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ÿ•ŸÑŸâ ÿπÿ±ÿ®Ÿäÿ©
function convertToArabicNumber(num) {
  const arabicNums = ['Ÿ†', 'Ÿ°', 'Ÿ¢', 'Ÿ£', 'Ÿ§', 'Ÿ•', 'Ÿ¶', 'Ÿß', 'Ÿ®', 'Ÿ©'];
  return num.toString().split('').map(d => arabicNums[+d]).join('');
}

// ŸÖŸÉŸàŸÜ ÿßŸÑŸÄ popup ÿßŸÑÿ¨ÿØŸäÿØ
const VerseActionsPopup = ({ verse, onClose, onCopy, onFavourite }) => {
  const { language } = useLanguage();
  return (
    <div className={styles.popupOverlay} onClick={onClose}>
      <div className={styles.popupContent} onClick={e => e.stopPropagation()}>
        <p className={styles.popupText}>{verse.text}</p>
        <div className={styles.popupButtons}>
          <button className={styles.copyButton} onClick={onCopy}>
            üìã {language === 'ar' ? 'ŸÜÿ≥ÿÆ' : language === 'en' ? 'Copy' : 'Copier'}
          </button>
          <button className={styles.favouriteButton} onClick={onFavourite}>
            ‚≠ê {language === 'ar' ? 'ŸÖŸÅÿ∂ŸÑÿ©' : language === 'en' ? 'Favorite' : 'Favori'}
          </button>
        </div>
        <button className={styles.closeButton} onClick={onClose}>&times;</button>
      </div>
    </div>
  );
};

export default function BibleContent() {
  const { language } = useLanguage();
  const searchParams = useSearchParams();

  const [bibleData, setBibleData] = useState(null);
  const [isLoadingBible, setIsLoadingBible] = useState(true);
  const [bookNamesData, setBookNamesData] = useState(null);
  const [hasBookNamesError, setHasBookNamesError] = useState(false);

  const [favouriteVerses, setFavouriteVerses] = useState({});
  const [favouriteChapters, setFavouriteChapters] = useState({});

  const [selectedBookIndex, setSelectedBookIndex] = useState(0);
  const [isBookDropdownOpen, setIsBookDropdownOpen] = useState(false);
  const bookDropdownRef = useRef(null);

  const [selectedChapterIndex, setSelectedChapterIndex] = useState(0);
  const [isChapterDropdownOpen, setIsChapterDropdownOpen] = useState(false);
  const chapterDropdownRef = useRef(null);
  
  const [selectedVerses, setSelectedVerses] = useState(new Set());
  
  const [copiedMessage, setCopiedMessage] = useState('');
  const [favouriteMessage, setFavouriteMessage] = useState('');
  
  const [popupVerse, setPopupVerse] = useState(null);
  const touchTimeout = useRef(null);
  const isLongPress = useRef(false);

  // ÿ¨ŸÑÿ® ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ŸÖŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä
  const fetchFavourites = useCallback(() => {
    try {
      const verses = JSON.parse(localStorage.getItem('favourite_verses')) || {};
      const chapters = JSON.parse(localStorage.getItem('favourite_chapters')) || {};
      setFavouriteVerses(verses);
      setFavouriteChapters(chapters);
    } catch (error) {
      console.error('Failed to load favorites from localStorage:', error);
    }
  }, []);

  // ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ŸÅŸä ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä
  const saveFavourites = useCallback((verses, chapters) => {
    try {
      localStorage.setItem('favourite_verses', JSON.stringify(verses));
      localStorage.setItem('favourite_chapters', JSON.stringify(chapters));
    } catch (error) {
      console.error('Failed to save favorites to localStorage:', error);
    }
  }, []);

  // ----------------- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ -----------------
  // ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ≥ŸÅÿ± ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ© ŸÖŸÜ ÿßŸÑŸÉÿßÿ¶ŸÜ
  const getBookName = useCallback((index) => {
    return bookNamesData?.[language]?.[index]?.name || 'Unknown Book';
  }, [bookNamesData, language]);

  // ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ≥ŸÅÿ± ŸÖŸÜ ÿßÿ≥ŸÖŸá (ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸÑÿ™ÿ™ŸÜÿßÿ≥ÿ® ŸÖÿπ ÿµŸäÿ∫ÿ© ÿßŸÑŸÉÿßÿ¶ŸÜ)
  const getBookIndexByName = useCallback((name) => {
    if (!bookNamesData?.[language] || !name) return 0;
    const index = bookNamesData[language].findIndex(book => book.name?.toLowerCase() === name.toLowerCase());
    return index !== -1 ? index : 0;
  }, [bookNamesData, language]);
  // ----------------- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ -----------------

  // ÿ¨ŸÑÿ® ÿßÿÆÿ™ÿµÿßÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≥ŸÅÿ±
  const getBookAbbreviation = useCallback((index) => {
    return bookNamesData?.abbreviations?.[index] || '';
  }, [bookNamesData]);

  useEffect(() => {
    fetchFavourites();
  }, [fetchFavourites]);
  
  // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ŸÑŸÅÿ™ÿ±ÿ© ŸÖÿ≠ÿØŸàÿØÿ©
  useEffect(() => {
    let timerId;
    if (copiedMessage || favouriteMessage) {
      timerId = setTimeout(() => {
        setCopiedMessage('');
        setFavouriteMessage('');
      }, 2000);
    }
    return () => {
      if (timerId) {
        clearTimeout(timerId);
      }
    };
  }, [copiedMessage, favouriteMessage]);

  // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÜÿ≥ÿØŸÑÿ© ŸÑŸÑÿ£ÿ≥ŸÅÿßÿ± ÿπŸÜÿØ ÿßŸÑŸÜŸÇÿ± ÿÆÿßÿ±ÿ¨Ÿáÿß
  useEffect(() => {
    const handleClickOutsideBook = (event) => {
      if (bookDropdownRef.current && !bookDropdownRef.current.contains(event.target)) {
        setIsBookDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutsideBook);
    return () => {
      document.removeEventListener('mousedown', handleClickOutsideBook);
    };
  }, []);

  // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÜÿ≥ÿØŸÑÿ© ŸÑŸÑÿ•ÿµÿ≠ÿßÿ≠ÿßÿ™ ÿπŸÜÿØ ÿßŸÑŸÜŸÇÿ± ÿÆÿßÿ±ÿ¨Ÿáÿß
  useEffect(() => {
    const handleClickOutsideChapter = (event) => {
      if (chapterDropdownRef.current && !chapterDropdownRef.current.contains(event.target)) {
        setIsChapterDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutsideChapter);
    return () => {
      document.removeEventListener('mousedown', handleClickOutsideChapter);
    };
  }, []);

  // ÿ¨ŸÑÿ® ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ£ÿ≥ŸÅÿßÿ±
  useEffect(() => {
    const loadBookNames = async () => {
      try {
        const response = await fetch('/data/bookNames.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} for /data/bookNames.json`);
        }
        const data = await response.json();
        setBookNamesData(data);
        setHasBookNamesError(false);
      } catch (error) {
        console.error('Failed to load bookNames:', error);
        setBookNamesData({});
        setHasBookNamesError(true);
      }
    };
    loadBookNames();
  }, []);

  // ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑŸÖŸÇÿØÿ≥ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÑÿ∫ÿ©
  useEffect(() => {
    const loadBible = async () => {
      setIsLoadingBible(true);
      setBibleData(null);
      
      try {
        let jsonFileName = '';
        if (language === 'ar') {
          jsonFileName = 'ar_svd.json';
        } else if (language === 'en') {
          jsonFileName = 'en_bbe.json';
        } else if (language === 'fr') {
          jsonFileName = 'fr_apee.json';
        } else {
          setBibleData([]);
          setIsLoadingBible(false);
          return;
        }

        const jsonFilePath = `/data/bibles/${jsonFileName}`;
        const response = await fetch(jsonFilePath);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} for ${jsonFilePath}`);
        }

        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          setBibleData(data);
          
          const bookNameFromUrl = searchParams.get('book');
          const chapterFromUrl = searchParams.get('chapter');

          let initialBookIndex = 0;
          let initialChapterIndex = 0;

          if (bookNameFromUrl && bookNamesData?.[language]) {
            initialBookIndex = getBookIndexByName(decodeURIComponent(bookNameFromUrl));
          }

          if (chapterFromUrl) {
            initialChapterIndex = parseInt(decodeURIComponent(chapterFromUrl)) - 1;
            if (isNaN(initialChapterIndex) || initialChapterIndex < 0 || initialChapterIndex >= data?.[initialBookIndex]?.chapters.length) {
              initialChapterIndex = 0;
            }
          }

          setSelectedBookIndex(initialBookIndex);
          setSelectedChapterIndex(initialChapterIndex);
          setSelectedVerses(new Set());
        } else {
          setBibleData([]);
        }
      } catch (error) {
        console.error(`Failed to fetch bible data for "${language}":`, error);
        setBibleData(null);
      } finally {
        setIsLoadingBible(false);
      }
    };

    if (language && ['ar', 'en', 'fr'].includes(language) && bookNamesData) {
      loadBible();
    } else if (language && ['ar', 'en', 'fr'].includes(language) && !bookNamesData) {
      // ŸÑÿß ŸäŸàÿ¨ÿØ ÿ•ÿ¨ÿ±ÿßÿ° ŸáŸÜÿßÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿØÿπÿßÿ° loadBible() ÿ®ŸÖÿ¨ÿ±ÿØ ÿ™ŸàŸÅÿ± bookNamesData
    } else {
      setIsLoadingBible(false);
      setBibleData([]);
    }
  }, [language, bookNamesData, searchParams, getBookIndexByName]);

  // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ≥ŸÅÿ± ÿßŸÑŸÖÿÆÿµÿµ
  const handleBookItemClick = (index) => {
    setSelectedBookIndex(index);
    setSelectedChapterIndex(0);
    setSelectedVerses(new Set());
    setIsBookDropdownOpen(false);
  };
  
  // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ÿßŸÑŸÖÿÆÿµÿµ
  const handleChapterItemClick = (index) => {
    setSelectedChapterIndex(index);
    setSelectedVerses(new Set());
    setIsChapterDropdownOpen(false);
  };

  const selectedBook = bibleData?.[selectedBookIndex] || null;
  const chapters = selectedBook?.chapters || [];
  const verses = chapters?.[selectedChapterIndex] || [];
  
  // ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ÿ™ÿ≥ŸÖŸäÿ© ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠
  const getChapterLabel = (index) => {
    if (language === 'ar') return `ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ${convertToArabicNumber(index + 1)}`;
    if (language === 'fr') return `Chapitre ${index + 1}`;
    return `Chapter ${index + 1}`;
  };

  // ÿØÿßŸÑÿ© ŸÑÿ¨ŸÑÿ® ÿ±ŸÇŸÖ ÿßŸÑÿ¢Ÿäÿ©
  const getVerseNumber = (index) => {
    return language === 'ar' ? convertToArabicNumber(index + 1) : index + 1;
  };

  // ÿØŸÖÿ¨ ŸÜÿµ ÿßŸÑÿ¢Ÿäÿ© ŸÖÿπ ÿßŸÑŸÖÿ±ÿ¨ÿπ
  const getFullVerseText = (bookIdx, chapterIdx, verseIdx, verseText) => {
    const bookName = getBookName(bookIdx);
    const chapterNumber = chapterIdx + 1;
    const verseNumber = verseIdx + 1;

    let reference;
    if (language === 'ar') {
      reference = `(${bookName} ${convertToArabicNumber(chapterNumber)}:${convertToArabicNumber(verseNumber)})`;
    } else {
      reference = `(${bookName} ${chapterNumber}:${verseNumber})`;
    }

    return `${verseText} ${reference}`;
  };

  // ÿØÿßŸÑÿ© ŸÑŸÜÿ≥ÿÆ ÿßŸÑŸÜÿµ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©
  const copyTextToClipboard = async (textToCopy) => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(textToCopy);
      } else {
        const el = document.createElement('textarea');
        el.value = textToCopy;
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
      }
      
      setCopiedMessage(
        language === 'ar' ? 'ÿ™ŸÖ ÿßŸÑŸÜÿ≥ÿÆ!' : language === 'en' ? 'Copied!' : 'Copi√©!'
      );
    } catch (err) {
      console.error('Failed to copy text: ', err);
      setCopiedMessage(
        language === 'ar' ? 'ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ≥ÿÆ!' : language === 'en' ? 'Failed to copy!' : '√âchec de la copie!'
      );
    }
  };
  
  const handleCopySingleVerse = (verse, index) => {
    const textToCopy = getFullVerseText(selectedBookIndex, selectedChapterIndex, index, verse);
    copyTextToClipboard(textToCopy);
  };

  const handleFavouriteChapter = () => {
    const chapterKey = `${selectedBookIndex}-${selectedChapterIndex}`;
    const isFavourite = favouriteChapters[chapterKey] !== undefined;
    
    let newFavouriteChapters = { ...favouriteChapters };
    if (isFavourite) {
      delete newFavouriteChapters[chapterKey];
      setFavouriteMessage(language === 'ar' ? 'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©!' : 'Chapter removed from favorites!');
    } else {
      const chapterData = {
        type: 'chapter',
        chapterKey,
        text: verses.map((v, i) => {
          let verseNumber = language === 'ar' ? convertToArabicNumber(i + 1) : i + 1;
          return `${verseNumber}. ${v}`;
        }).join('\n'),
        bookName: getBookName(selectedBookIndex),
        bookNameAbbrev: getBookAbbreviation(selectedBookIndex),
        chapter: selectedChapterIndex,
        language: language,
      };
      newFavouriteChapters[chapterKey] = chapterData;
      setFavouriteMessage(language === 'ar' ? 'ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ÿ•ŸÑŸâ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©!' : 'Chapter added to favorites!');
    }
    
    setFavouriteChapters(newFavouriteChapters);
    saveFavourites(favouriteVerses, newFavouriteChapters);
  };

  const handleFavouriteSingleVerse = (verse, verseIndex) => {
    const verseKey = `${selectedBookIndex}-${selectedChapterIndex}-${verseIndex}`;
    const isFavourite = favouriteVerses[verseKey] !== undefined;
    
    let newFavouriteVerses = { ...favouriteVerses };
    if (isFavourite) {
      delete newFavouriteVerses[verseKey];
      setFavouriteMessage(language === 'ar' ? 'ÿ™ŸÖ ÿßŸÑÿ≠ÿ∞ŸÅ ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©!' : 'Removed from favorites!');
    } else {
      const verseData = {
        type: 'verse',
        verseKey,
        text: verse,
        bookName: getBookName(selectedBookIndex),
        bookNameAbbrev: getBookAbbreviation(selectedBookIndex),
        chapter: selectedChapterIndex,
        verseIndex: verseIndex,
        language: language,
      };
      newFavouriteVerses[verseKey] = verseData;
      setFavouriteMessage(language === 'ar' ? 'ÿ™ŸÖ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ•ŸÑŸâ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©!' : 'Added to favorites!');
    }
    
    setFavouriteVerses(newFavouriteVerses);
    saveFavourites(newFavouriteVerses, favouriteChapters);
  };

  const handleVerseSelection = (verseKey) => {
    setSelectedVerses(prevSelected => {
      const newSelection = new Set(prevSelected);
      if (newSelection.has(verseKey)) {
        newSelection.delete(verseKey);
      } else {
        newSelection.add(verseKey);
      }
      return newSelection;
    });
  };

  const handleCopySelectedVerses = () => {
    if (selectedVerses.size === 0) return;

    let compiledText = [];
    const sortedSelectedVerseKeys = Array.from(selectedVerses).sort((a, b) => {
      const [, , verseIdxA] = a.split('-').map(Number);
      const [, , verseIdxB] = b.split('-').map(Number);
      return verseIdxA - verseIdxB;
    });

    sortedSelectedVerseKeys.forEach(key => {
      const [bookIdx, chapterIdx, verseIdx] = key.split('-').map(Number);
      if (bookIdx === selectedBookIndex && chapterIdx === selectedChapterIndex && verses[verseIdx]) {
        compiledText.push(getFullVerseText(bookIdx, chapterIdx, verseIdx, verses[verseIdx]));
      }
    });

    const textToCopy = compiledText.join('\n\n');
    copyTextToClipboard(textToCopy);
    setSelectedVerses(new Set());
  };

  const handleFavouriteSelectedVerses = () => {
    if (selectedVerses.size === 0) return;
    
    let newFavouriteVerses = { ...favouriteVerses };

    for (const key of Array.from(selectedVerses)) {
      const isFavourite = favouriteVerses[key] !== undefined;
      const [bookIdx, chapterIdx, verseIdx] = key.split('-').map(Number);

      if (isFavourite) {
        delete newFavouriteVerses[key];
      } else {
        const verseData = {
          type: 'verse',
          verseKey: key,
          text: verses[verseIdx],
          bookName: getBookName(bookIdx),
          bookNameAbbrev: getBookAbbreviation(bookIdx),
          chapter: chapterIdx,
          verseIndex: verseIdx,
          language: language,
        };
        newFavouriteVerses[key] = verseData;
      }
    }
    
    setFavouriteVerses(newFavouriteVerses);
    saveFavourites(newFavouriteVerses, favouriteChapters);
    
    setFavouriteMessage(
      language === 'ar' ? `ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© (${convertToArabicNumber(selectedVerses.size)} ÿ¢Ÿäÿ©)!` : `Favorites updated (${selectedVerses.size} Verses)!`
    );
    setSelectedVerses(new Set());
  };
  
  const isCurrentChapterFavourite = favouriteChapters[`${selectedBookIndex}-${selectedChapterIndex}`] !== undefined;

  // ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÑŸÖÿ≥ÿ© ÿßŸÑŸàÿßÿ≠ÿØÿ© ŸàÿßŸÑŸÑŸÖÿ≥ÿ© ÿßŸÑŸÖÿ∑ŸàŸÑÿ©
  const handleVerseTouchStart = (e, verseKey, verseText) => {
      e.stopPropagation();
      isLongPress.current = false;
      touchTimeout.current = setTimeout(() => {
          isLongPress.current = true;
          setPopupVerse({ key: verseKey, text: verseText });
      }, 500); // 500ms for a long press
  };

  const handleVerseTouchEnd = (e, verseKey) => {
      e.stopPropagation();
      clearTimeout(touchTimeout.current);
      if (!isLongPress.current) {
          // This is a single tap
          handleVerseSelection(verseKey);
      }
      isLongPress.current = false;
  };

  const handleClosePopup = () => {
      setPopupVerse(null);
  };
  
  const handleCopyPopup = () => {
    if (popupVerse) {
        const [bookIdx, chapterIdx, verseIdx] = popupVerse.key.split('-').map(Number);
        const textToCopy = getFullVerseText(bookIdx, chapterIdx, verseIdx, popupVerse.text);
        copyTextToClipboard(textToCopy);
    }
    handleClosePopup();
  };

  const handleFavouritePopup = () => {
    if (popupVerse) {
        const [bookIdx, chapterIdx, verseIdx] = popupVerse.key.split('-').map(Number);
        handleFavouriteSingleVerse(popupVerse.text, verseIdx);
    }
    handleClosePopup();
  };
  
  // ŸÑÿ∂ŸÖÿßŸÜ ÿπÿØŸÖ ÿ≠ÿØŸàÿ´ conflict ÿ®ŸäŸÜ ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÑŸÖÿ≥ ŸàÿßŸÑŸÜŸÇÿ±
  const isTouchDevice = () => {
      if (typeof window === 'undefined') return false;
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  };

  if (isLoadingBible || bookNamesData === null) {
    return (
      <div className={styles.loadingMessage}>
        {language === 'ar' ? 'ÿ¨ÿßÿ±Ÿç ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑŸÖŸÇÿØÿ≥...' : language === 'en' ? 'Loading Bible...' : 'Chargement de la Bible...'}
      </div>
    );
  }

  if (!bibleData || bibleData.length === 0 || hasBookNamesError || !bookNamesData?.[language] || Object.keys(bookNamesData[language]).length === 0) {
    return (
      <div className={styles.errorMessage}>
        {language === 'ar' ? 'ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑŸÖŸÇÿØÿ≥ ÿ£Ÿà ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅÿßÿ±ÿ∫ÿ©.' : language === 'en' ? 'Failed to load Bible data or data is empty.' : '√âchec du chargement des donn√©es de la Bible ou donn√©es vides.'}
        <br />
        {hasBookNamesError && (language === 'ar' ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ≥ÿßÿ± ŸÖŸÑŸÅ bookNames.json.' : 'Please check the path to bookNames.json.')}
        {!hasBookNamesError && (language === 'ar' ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ: 1. ŸÇŸäŸÖÿ© ÿßŸÑŸÑÿ∫ÿ© ŸÖŸÜ `LanguageContext`. 2. ŸÖÿ≥ÿßÿ±ÿßÿ™ ŸÖŸÑŸÅÿßÿ™ JSON ŸÅŸä ŸÖÿ¨ŸÑÿØ `public/data/bibles`. 3. ÿ®ŸÜŸäÿ© ŸÖŸÑŸÅÿßÿ™ JSON.' : 'Please check: 1. Language value from `LanguageContext`. 2. JSON file paths in `public/data/bibles` folder. 3. JSON file structure.')}
      </div>
    );
  }

  return (
    <div dir={language === 'ar' ? 'rtl' : 'ltr'}>
      <h1 className={styles.title}>
        üìö {
          language === 'ar'
            ? 'ÿØÿ±ÿßÿ≥ÿ© ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑŸÖŸÇÿØÿ≥'
            : language === 'en'
            ? 'Bible Study'
            : '√âtude de la Bible'
        }
      </h1>
      <div className={styles.controls}>
        {/* ŸÇÿßÿ¶ŸÖÿ© ŸÖŸÜÿ≥ÿØŸÑÿ© ŸÖÿÆÿµÿµÿ© ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ≥ŸÅÿ± */}
        <div className={styles.customSelectWrapper} ref={bookDropdownRef}>
          <label className={styles.label}>
            üìñ {
              language === 'ar'
                ? 'ÿßÿÆÿ™ÿ± ÿßŸÑÿ≥ŸÅÿ±:'
                : language === 'en'
                ? 'Select Book:'
                : 'Choisir un livre:'
            }
          </label>
          <div
            className={`${styles.selectTrigger} ${isBookDropdownOpen ? styles.active : ''}`}
            onClick={() => setIsBookDropdownOpen(!isBookDropdownOpen)}
          >
            <span>{getBookName(selectedBookIndex)}</span>
            <div className={styles.arrow}></div>
          </div>
          <ul className={`${styles.dropdownMenu} ${isBookDropdownOpen ? styles.open : ''}`}>
            {/* ----------------- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ----------------- */}
            {bookNamesData?.[language]?.map((book, index) => (
              <li
                key={index}
                className={`${styles.dropdownItem} ${selectedBookIndex === index ? styles.selected : ''}`}
                onClick={() => handleBookItemClick(index)}
              >
                {book.name} {/* ŸáŸÜÿß ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© .name ŸÑÿπÿ±ÿ∂ ÿßÿ≥ŸÖ ÿßŸÑÿ≥ŸÅÿ± ŸÅŸÇÿ∑ */}
              </li>
            ))}
            {/* ----------------- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ----------------- */}
          </ul>
        </div>
        
        {/* ŸÇÿßÿ¶ŸÖÿ© ŸÖŸÜÿ≥ÿØŸÑÿ© ŸÖÿÆÿµÿµÿ© ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ */}
        <div className={styles.customSelectWrapper} ref={chapterDropdownRef}>
          <label className={styles.label}>
            üî¢ {
              language === 'ar'
                ? 'ÿßÿÆÿ™ÿ± ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠:'
                : language === 'en'
                ? 'Select Chapter:'
                : 'Choisir un chapitre:'
            }
          </label>
          <div
            className={`${styles.selectTrigger} ${isChapterDropdownOpen ? styles.active : ''}`}
            onClick={() => setIsChapterDropdownOpen(!isChapterDropdownOpen)}
          >
            <span>{getChapterLabel(selectedChapterIndex)}</span>
            <div className={styles.arrow}></div>
          </div>
          <ul className={`${styles.dropdownMenu} ${isChapterDropdownOpen ? styles.open : ''}`}>
            {chapters?.map((_, index) => (
              <li
                key={index}
                className={`${styles.dropdownItem} ${selectedChapterIndex === index ? styles.selected : ''}`}
                onClick={() => handleChapterItemClick(index)}
              >
                {getChapterLabel(index)}
              </li>
            ))}
          </ul>
        </div>
      </div>

      {copiedMessage && (
        <div className={`${styles.messageBox} ${styles.copiedMessage}`}>
          {copiedMessage}
        </div>
      )}

      {favouriteMessage && (
        <div className={`${styles.messageBox} ${styles.favouriteMessage}`}>
          {favouriteMessage}
        </div>
      )}

      {selectedVerses.size > 0 && (
        <div className={styles.actionButtons}>
          <button
            onClick={handleCopySelectedVerses}
            className={styles.copySelectedButton}
          >
            {language === 'ar' ? `ŸÜÿ≥ÿÆ ${convertToArabicNumber(selectedVerses.size)} ÿ¢Ÿäÿ© ŸÖÿÆÿ™ÿßÿ±ÿ©` : `Copy ${selectedVerses.size} Selected Verses`}
          </button>
          <button
            onClick={handleFavouriteSelectedVerses}
            className={styles.favouriteSelectedButton}
          >
            {language === 'ar' ? `ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© (${convertToArabicNumber(selectedVerses.size)} ÿ¢Ÿäÿ©)` : `Update Favorites (${selectedVerses.size} Verses)`}
          </button>
        </div>
      )}

      <div>
        <h2 className={styles.chapterTitle}>
          üìú {getBookName(selectedBookIndex)} {getChapterLabel(selectedChapterIndex)}
        </h2>
        
        <button
          onClick={handleFavouriteChapter}
          className={`${styles.favouriteChapterButton} ${isCurrentChapterFavourite ? styles.isFavourite : ''}`}
          title={isCurrentChapterFavourite ? (language === 'ar' ? 'ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©' : 'Remove Chapter from Favorites') : (language === 'ar' ? 'ÿ£ÿ∂ŸÅ ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ŸÑŸÑŸÖŸÅÿ∂ŸÑÿ©' : 'Add Chapter to Favorites')}
        >
          {isCurrentChapterFavourite ? (language === 'ar' ? 'ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠' : 'Remove Chapter') : (language === 'ar' ? 'ÿ£ÿ∂ŸÅ ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠' : 'Add Chapter')} ‚≠ê
        </button>
        
        <div className={styles.verseContainer}>
          {verses?.map((verse, index) => {
            const verseKey = `${selectedBookIndex}-${selectedChapterIndex}-${index}`;
            const isSelected = selectedVerses.has(verseKey);
            const isFavourite = favouriteVerses[verseKey] !== undefined;

            return (
              <span 
                key={index} 
                className={`${styles.singleVerse} ${isSelected ? styles.selectedVerse : ''} ${isFavourite ? styles.favouriteVerse : ''}`}
                // ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÑŸÖÿ≥ ŸÑŸÑÿ¥ÿßÿ¥ÿßÿ™ ÿßŸÑÿµÿ∫Ÿäÿ±ÿ©
                onTouchStart={(e) => isTouchDevice() && handleVerseTouchStart(e, verseKey, verse)}
                onTouchEnd={(e) => isTouchDevice() && handleVerseTouchEnd(e, verseKey)}
                // ÿ≠ÿØÿ´ ÿßŸÑŸÜŸÇÿ± ŸÑŸÑÿ¥ÿßÿ¥ÿßÿ™ ÿßŸÑŸÉÿ®Ÿäÿ±ÿ©
                onClick={(e) => !isTouchDevice() && handleVerseSelection(verseKey)}
              >
                <div 
                  className={styles.verseNumberAndText}
                >
                  <input
                    type="checkbox"
                    checked={isSelected}
                    onChange={() => handleVerseSelection(verseKey)}
                    className={styles.verseCheckbox}
                    onClick={(e) => e.stopPropagation()}
                  />
                  <strong className={styles.verseNumber}>
                    {getVerseNumber(index)}.
                  </strong>{' '}
                  {verse}{' '}
                </div>

                <div className={styles.verseActions}>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleFavouriteSingleVerse(verse, index);
                    }}
                    className={`${styles.favouriteButton} ${isFavourite ? styles.isFavourite : ''}`}
                    title={language === 'ar' ? (isFavourite ? 'ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©' : 'ÿ£ÿ∂ŸÅ ŸÑŸÑŸÖŸÅÿ∂ŸÑÿ©') : (isFavourite ? 'Remove from Favorites' : 'Add to Favorites')}
                  >
                    ‚≠ê
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleCopySingleVerse(verse, index);
                    }}
                    className={styles.copyButton}
                    title={language === 'ar' ? 'ŸÜÿ≥ÿÆ ÿßŸÑÿ¢Ÿäÿ©' : language === 'en' ? 'Copy Verse' : 'Copier le verset'}
                  >
                    üìã
                  </button>
                </div>
              </span>
            );
          }) || <div className={styles.noVersesMessage}>
            {language === 'ar' ? 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ¢Ÿäÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸáÿ∞ÿß ÿßŸÑÿ•ÿµÿ≠ÿßÿ≠ ÿ£Ÿà ÿßŸÑÿ≥ŸÅÿ±.' : 'No verses available for this chapter or book.'}
          </div>}
        </div>
      </div>
      
      {popupVerse && (
        <VerseActionsPopup 
            verse={popupVerse} 
            onClose={handleClosePopup}
            onCopy={handleCopyPopup}
            onFavourite={handleFavouritePopup}
        />
      )}
    </div>
  );
}